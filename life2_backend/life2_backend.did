// Life2 Backend - Sparse On-Chain Implementation
// 10 generations/second using sparse iteration

type SparseCell = record {
    x: nat16;
    y: nat16;
    owner: nat8;
    coins: nat8;
};

type GameState = record {
    generation: nat64;
    alive_cells: vec SparseCell;
    territory: vec SparseCell;
    players: vec principal;
    balances: vec nat64;
    player_num: opt nat8;
};

type PlaceResult = record {
    placed: nat32;
    generation: nat64;
    new_balance: nat64;
};

service : {
    // Player actions
    join_game: () -> (variant { Ok: nat8; Err: text });
    place_cells: (vec record { int32; int32 }) -> (variant { Ok: PlaceResult; Err: text });

    // Queries (FREE - no cycles cost to caller)
    get_state: () -> (GameState) query;
    get_generation: () -> (nat64) query;
    get_alive_count: () -> (nat32) query;
    get_potential_count: () -> (nat32) query;
    get_balance: () -> (variant { Ok: nat64; Err: text }) query;
    get_next_wipe: () -> (nat8, nat64) query;
    is_running: () -> (bool) query;
    greet: (text) -> (text) query;

    // Admin (requires admin principal)
    pause_game: () -> (variant { Ok; Err: text });
    resume_game: () -> (variant { Ok; Err: text });
    reset_game: () -> (variant { Ok; Err: text });
}
