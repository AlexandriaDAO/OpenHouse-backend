// Life2 Backend - Sparse On-Chain Implementation
// 10 generations/second using sparse iteration

type SparseCell = record {
    x: nat16;
    y: nat16;
    owner: nat8;
    coins: nat8;
};

type GameState = record {
    generation: nat64;
    alive_cells: vec SparseCell;
    territory: vec SparseCell;
    players: vec principal;
    balances: vec nat64;
    player_num: opt nat8;
    quadrant_controllers: vec nat8;
};

type PlaceResult = record {
    placed: nat32;
    generation: nat64;
    new_balance: nat64;
};

type SlotInfo = record {
    slot: nat8;
    occupied: bool;
    cell_count: nat32;
    territory_cells: nat32;
    territory_coins: nat32;
};

type QuadrantInfo = record {
    quadrant: nat8;
    territory_by_player: vec nat32;
    total_territory: nat32;
    coins_by_player: vec nat32;
    total_coins: nat32;
    controller: nat8;
};

service : {
    // Player actions
    join_game: () -> (variant { Ok: nat8; Err: text });
    join_slot: (nat8) -> (variant { Ok: nat8; Err: text });
    place_cells: (vec record { int32; int32 }) -> (variant { Ok: PlaceResult; Err: text });
    faucet: () -> (variant { Ok: nat64; Err: text });

    // Queries (FREE - no cycles cost to caller)
    get_state: () -> (GameState) query;
    get_slots_info: () -> (vec SlotInfo) query;
    get_quadrant_info: () -> (vec QuadrantInfo) query;
    get_generation: () -> (nat64) query;
    get_alive_count: () -> (nat32) query;
    get_potential_count: () -> (nat32) query;
    get_balance: () -> (variant { Ok: nat64; Err: text }) query;
    get_next_wipe: () -> (nat8, nat64) query;
    is_running: () -> (bool) query;
    greet: (text) -> (text) query;

    // Admin (requires admin principal)
    pause_game: () -> (variant { Ok; Err: text });
    resume_game: () -> (variant { Ok; Err: text });
    reset_game: () -> (variant { Ok; Err: text });
}
