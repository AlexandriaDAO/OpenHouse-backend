# AUTONOMOUS PR ORCHESTRATOR - DO NOT SKIP

**You are an autonomous PR orchestrator. Your ONLY job is to implement this plan and create a PR.**

## Isolation Check (RUN FIRST)
```bash
REPO_ROOT=$(git rev-parse --show-toplevel)
if [ "$REPO_ROOT" = "/home/theseus/alexandria/openhouse" ]; then
    echo "FATAL: In main repo. Must be in worktree."
    echo "Worktree: /home/theseus/alexandria/openhouse-dice-vrf"
    exit 1
fi
echo "In isolated worktree: $REPO_ROOT"
```

## Your Autonomous Workflow (NO QUESTIONS ALLOWED)
1. **Verify isolation** - You must be in worktree: `/home/theseus/alexandria/openhouse-dice-vrf`
2. **Implement feature** - Follow plan sections below
3. **Build & Deploy to Mainnet**:
   ```bash
   cargo build --target wasm32-unknown-unknown --release
   ./deploy.sh --dice-only
   ```
4. **Verify deployment**:
   ```bash
   dfx canister --network ic status dice_backend
   dfx canister --network ic call whchi-hyaaa-aaaao-a4ruq-cai get_seed_info
   echo "Visit: https://pezw3-laaaa-aaaal-qssoa-cai.icp0.io"
   ```
5. **Create PR** (MANDATORY):
   ```bash
   git add .
   git commit -m "security(dice): implement per-game VRF to prevent seed caching exploitation"
   git push -u origin feature/dice-vrf-security
   gh pr create --title "Security: Per-game VRF for Dice Backend" --body "$(cat <<'EOF'
## Summary
- Removes vulnerable cached seed system that stored randomness for 5 minutes
- Implements per-game VRF calls using IC's `raw_rand()` like Plinko
- Eliminates node operator exploitation window
- Maintains provably fair verification capability

## Security Issue Fixed
The previous implementation cached a server seed that rotated every 5 minutes or 10,000 games.
Node operators could theoretically read this seed from canister memory and predict dice outcomes
within the rotation window.

## Changes
- `seed.rs`: Complete rewrite to per-game VRF
- `game.rs`: Updated to use async random generation
- Removed: Seed rotation timers, cached seed state, stable seed storage

## Test plan
- [ ] Verify dice game works on mainnet
- [ ] Confirm no seed caching (each game gets fresh randomness)
- [ ] Check provably fair verification still works

Deployed to mainnet:
- Frontend: https://pezw3-laaaa-aaaal-qssoa-cai.icp0.io
- Dice Backend: whchi-hyaaa-aaaao-a4ruq-cai

Generated with [Claude Code](https://claude.com/claude-code)
EOF
)"
   ```
6. **Iterate autonomously**:
   - FOR i=1 to 5:
     - Check review: `gh pr view [NUM] --json comments`
     - Count P0 issues
     - IF P0 > 0: Fix immediately, commit, push, sleep 300s, continue
     - IF P0 = 0: Report success, EXIT
   - After 5 iterations: Escalate to human

## CRITICAL RULES
- NO questions ("should I?", "want me to?", "is it done?")
- NO skipping PR creation - it's MANDATORY
- NO stopping after implementation - create PR immediately
- MAINNET DEPLOYMENT: All changes go directly to production
- After sleep: IMMEDIATELY continue (no pause)
- ONLY stop at: approved, max iterations, or error

**Branch:** `feature/dice-vrf-security`
**Worktree:** `/home/theseus/alexandria/openhouse-dice-vrf`

---

# Implementation Plan: Per-Game VRF Security Fix

## Problem Statement

The current dice_backend uses a **cached seed system** that stores randomness in stable memory and rotates every 5 minutes:

```
dice_backend/src/seed.rs:16
pub const SEED_ROTATION_INTERVAL_NS: u64 = 300_000_000_000; // 5 minutes
```

**Vulnerability**: Node operators who run replica nodes can read canister memory and extract the cached `current_seed`. With this seed, they can predict all dice outcomes for up to 5 minutes or 10,000 games, allowing them to place winning bets with 100% certainty.

## Solution: Per-Game VRF (Like Plinko)

The Plinko backend demonstrates the correct approach:

```rust
// plinko_backend/src/lib.rs:70
let random_bytes = raw_rand().await
    .map_err(|e| format!("Randomness unavailable: {:?}", e))?;
```

Each game calls `raw_rand()` directly. The randomness is generated by IC consensus and never stored, making prediction impossible.

## Current State

### Files to Modify

| File | Action | Description |
|------|--------|-------------|
| `dice_backend/src/seed.rs` | REWRITE | Remove all caching, implement per-game VRF |
| `dice_backend/src/game.rs` | MODIFY | Update to use async random generation |
| `dice_backend/src/lib.rs` | MODIFY | Remove seed-related endpoints and lifecycle hooks |
| `dice_backend/src/types.rs` | MODIFY | Remove `RandomnessSeed` struct |

### Current Vulnerable Flow

```
1. On init/post_upgrade: Call raw_rand() once, store seed
2. On play_dice: Use cached seed + nonce to generate result (INSTANT)
3. Every 5 min or 10k games: Rotate seed
```

### New Secure Flow

```
1. On play_dice: Call raw_rand() (ASYNC)
2. Use fresh VRF bytes to generate result
3. Return result with proof data for verification
```

## Implementation Pseudocode

### 1. `dice_backend/src/seed.rs` (REWRITE)

```rust
// PSEUDOCODE - Complete rewrite
use ic_cdk::management_canister::raw_rand;
use sha2::{Digest, Sha256};
use crate::types::MAX_NUMBER;

// No more cached seeds, no more timers, no more stable storage

/// Generate dice roll using per-game VRF
/// Returns: (rolled_number, server_seed, nonce) for verification
pub async fn generate_dice_roll_vrf(client_seed: &str) -> Result<(u8, [u8; 32], u64), String> {
    // Get fresh VRF randomness (async call to IC consensus)
    let random_bytes = raw_rand().await
        .map_err(|e| format!("VRF unavailable: {:?}. Please retry.", e))?;

    // Use first 32 bytes as server seed
    let server_seed: [u8; 32] = random_bytes[0..32]
        .try_into()
        .map_err(|_| "Insufficient randomness")?;

    // Generate unique nonce from timestamp
    let nonce = ic_cdk::api::time();

    // Combine server_seed + client_seed + nonce
    let mut hasher = Sha256::new();
    hasher.update(server_seed);
    hasher.update(client_seed.as_bytes());
    hasher.update(nonce.to_be_bytes());
    let hash = hasher.finalize();

    // Convert to 0-100 range
    let rand_u64 = u64::from_be_bytes(hash[0..8].try_into().unwrap());
    let roll = (rand_u64 % (MAX_NUMBER as u64 + 1)) as u8;

    Ok((roll, server_seed, nonce))
}

/// Verify game result for provable fairness
/// Players can call this with the server_seed revealed after game
pub fn verify_game_result(
    server_seed: [u8; 32],
    client_seed: String,
    nonce: u64,
    expected_roll: u8
) -> Result<bool, String> {
    let mut hasher = Sha256::new();
    hasher.update(server_seed);
    hasher.update(client_seed.as_bytes());
    hasher.update(nonce.to_be_bytes());
    let hash = hasher.finalize();

    let rand_u64 = u64::from_be_bytes(hash[0..8].try_into().unwrap());
    let calculated_roll = (rand_u64 % (MAX_NUMBER as u64 + 1)) as u8;

    Ok(calculated_roll == expected_roll)
}

/// Get hash of server seed for pre-game commitment (provable fairness)
pub fn hash_server_seed(server_seed: &[u8; 32]) -> String {
    let mut hasher = Sha256::new();
    hasher.update(server_seed);
    format!("{:x}", hasher.finalize())
}
```

### 2. `dice_backend/src/game.rs` (MODIFY)

```rust
// PSEUDOCODE - Modify play_dice function

pub async fn play_dice(
    bet_amount: u64,
    target_number: u8,
    direction: RollDirection,
    client_seed: String,
    caller: Principal
) -> Result<DiceGameResult, String> {  // Changed return type
    // ... existing validation code stays the same ...

    // REMOVE: maybe_schedule_seed_rotation();
    // REMOVE: let (rolled_number, _nonce, _server_seed_hash) = generate_dice_roll_instant(&client_seed)?;

    // NEW: Use per-game VRF (async)
    let (rolled_number, server_seed, nonce) = seed::generate_dice_roll_vrf(&client_seed).await?;
    let server_seed_hash = seed::hash_server_seed(&server_seed);

    // ... existing bet deduction and settlement code stays the same ...

    // Return enhanced result with provable fairness data
    Ok(DiceGameResult {
        rolled_number,
        is_win,
        payout,
        server_seed,      // Revealed immediately (safe - VRF is per-game)
        server_seed_hash, // For verification
        nonce,
        client_seed: client_seed.clone(),
    })
}
```

### 3. `dice_backend/src/types.rs` (MODIFY)

```rust
// PSEUDOCODE - Update result type

// REMOVE: RandomnessSeed struct entirely

// UPDATE: MinimalGameResult -> DiceGameResult with verification data
#[derive(CandidType, Deserialize, Clone, Debug)]
pub struct DiceGameResult {
    pub rolled_number: u8,
    pub is_win: bool,
    pub payout: u64,
    // Provably fair verification data
    pub server_seed: [u8; 32],
    pub server_seed_hash: String,
    pub nonce: u64,
    pub client_seed: String,
}

// Keep MinimalGameResult as alias for backward compatibility during transition
pub type MinimalGameResult = DiceGameResult;
```

### 4. `dice_backend/src/lib.rs` (MODIFY)

```rust
// PSEUDOCODE - Clean up lifecycle and endpoints

// REMOVE from post_upgrade:
// seed::restore_seed_state();

// REMOVE these endpoints entirely:
// - get_current_seed_hash() - no more cached seed
// - get_seed_info() - no more cached seed

// KEEP verify_game_result - still useful for verification
```

## Removed Components

| Component | Reason |
|-----------|--------|
| `SEED_STATE` thread_local | No more caching |
| `SEED_CELL` stable storage | No more persistence |
| `LAST_ROTATION_CELL` | No more rotation |
| `SEED_ROTATION_INTERVAL_NS` | No more rotation |
| `MAX_GAMES_PER_SEED` | No more rotation |
| `initialize_seed()` | No more initialization |
| `restore_seed_state()` | No more restore |
| `maybe_schedule_seed_rotation()` | No more rotation |
| `rotate_seed_async()` | No more rotation |
| `get_current_seed_hash()` | No cached seed to hash |
| `get_seed_info()` | No seed info to return |

## Trade-offs

| Aspect | Old (Cached Seed) | New (Per-Game VRF) |
|--------|-------------------|-------------------|
| **Security** | Vulnerable (5-min window) | Secure (no prediction) |
| **Latency** | ~0ms (instant) | ~200-500ms (consensus) |
| **Cycle cost** | Low (one VRF per 5min) | Higher (one VRF per game) |
| **Complexity** | Complex (timers, rotation) | Simple (just call VRF) |

The latency increase is acceptable because:
1. Security is paramount for a casino
2. Users expect some processing time for bets
3. Plinko already uses this pattern successfully

## Memory IDs Cleanup

Check `defi_accounting/memory_ids.rs` for:
- `SEED_STATE_MEMORY_ID` - can be freed/reused
- `NONCE_COUNTER_MEMORY_ID` - can be freed/reused

These stable memory slots are no longer needed but should be documented as deprecated rather than immediately reused to avoid any upgrade issues.

## Verification Flow (Provably Fair)

1. **Pre-game**: Player provides `client_seed`
2. **Game**: Backend generates `server_seed` via VRF, combines with `client_seed` + `nonce`
3. **Result**: Returns `server_seed` (safe to reveal - already used)
4. **Verify**: Anyone can call `verify_game_result(server_seed, client_seed, nonce, expected_roll)`

This is simpler than the old commit-reveal scheme because VRF is truly random and revealed immediately.

## Deployment Notes

- **Canister**: `whchi-hyaaa-aaaao-a4ruq-cai` (Dice Backend)
- **Deploy command**: `./deploy.sh --dice-only`
- **Breaking change**: Result type changes from `MinimalGameResult` to include verification data

## Post-Deployment Verification

```bash
# 1. Call get_seed_info - should now return error or empty (no cached seed)
dfx canister --network ic call whchi-hyaaa-aaaao-a4ruq-cai get_seed_info

# 2. Play a test game and verify result includes server_seed
# (Would need ICP/tokens to actually test)

# 3. Verify the game works on frontend
# Visit https://pezw3-laaaa-aaaal-qssoa-cai.icp0.io/dice
```
