//! Boundary Condition Exploit Tests
//!
//! These tests attempt to exploit edge cases at system boundaries:
//! - Minimum/maximum bet amounts
//! - Pool drain scenarios
//! - Dust attacks
//! - Operating balance limits

use crate::defi_accounting::tests::stress_tests::AccountingModel;

#[test]
fn attack_min_bet_bypass() {
    println!("\nğŸ”´ ATTACK: Minimum bet bypass");
    println!("Strategy: Attempt to place bets below minimum threshold");

    let mut model = AccountingModel::new();

    // Setup: Create pool
    println!("Setup: Creating pool...");
    let lp = 1;
    model.lp_deposit(lp, 100_000_000).expect_success(); // 100 USDT

    let attacker = 999;
    model.user_deposit(attacker, 10_000_000).expect_success(); // 10 USDT

    // Attack: Try various bets below minimum
    println!("\nğŸš¨ ATTACK EXECUTION:");

    let invalid_bets = vec![
        (0, "Zero bet"),
        (1, "1 unit bet"),
        (9_999, "Just below minimum (9,999 units)"),
    ];

    for (bet_amount, desc) in invalid_bets {
        println!("  Attempting: {} ({})", desc, bet_amount);

        let result = model.settle_bet(attacker, bet_amount, 0);

        // Should be rejected or handled gracefully
        if result.is_success() {
            println!("    âš ï¸  Accepted (checking if harmful...)");

            // If accepted, verify invariants
            let check = model.check_invariant();
            assert!(
                check.is_ok(),
                "ğŸ”¥ EXPLOIT SUCCEEDED: Small bet broke invariant for {}: {:?}",
                desc, check
            );
        } else {
            println!("    âœ“ Rejected: {}", result.message());
        }
    }

    // Verify: Valid minimum bet should work
    println!("\n  Attempting: Valid minimum bet (10,000 units)");
    let valid_result = model.settle_bet(attacker, 10_000, 0);

    if !valid_result.is_success() {
        println!("    âš ï¸  Valid bet rejected: {}", valid_result.message());
        println!("    (This might be OK if there's another reason like insufficient balance)");
    } else {
        println!("    âœ“ Valid bet accepted");
    }

    // Check final invariants
    println!("\nâœ… DEFENSE CHECK:");
    let check = model.check_invariant();
    assert!(
        check.is_ok(),
        "ğŸ”¥ EXPLOIT SUCCEEDED: Invariant broken: {:?}",
        check
    );

    println!("  âœ“ Minimum bet enforcement working");
    println!("\nâœ… ATTACK THWARTED: Cannot bypass minimum bet");
}

#[test]
fn attack_max_payout_bypass() {
    println!("\nğŸ”´ ATTACK: Maximum payout bypass");
    println!("Strategy: Win more than max allowed payout in single bet");

    let mut model = AccountingModel::new();

    // Setup: Create pool with known size
    println!("Setup: Creating pool...");
    let lp = 1;
    let pool_size = 100_000_000; // 100 USDT
    model.lp_deposit(lp, pool_size).expect_success();

    println!("  Pool reserve: {} USDT", model.pool_reserve / 1_000_000);

    // In plinko, max payout should be limited to prevent pool drain
    // Let's assume 15% of pool (like dice backend does)
    let max_allowed_payout = model.pool_reserve * 15 / 100;
    println!("  Max allowed payout (15% of pool): {} USDT", max_allowed_payout / 1_000_000);

    // Attack: Try to win more than max payout
    println!("\nğŸš¨ ATTACK EXECUTION:");
    let attacker = 999;
    model.user_deposit(attacker, pool_size / 2).expect_success(); // 50 USDT

    // Try to win 90% of pool (exceeds 15% limit)
    let huge_bet = pool_size / 10; // 10 USDT bet
    let huge_payout = pool_size * 9 / 10; // 90 USDT payout (9x)

    println!("  Attempting bet: {} USDT for {} USDT payout",
             huge_bet / 1_000_000,
             huge_payout / 1_000_000);

    let attack_result = model.settle_bet(attacker, huge_bet, huge_payout);

    // Verify: Should be rejected or pool should remain solvent
    println!("\nâœ… DEFENSE CHECK:");

    if attack_result.is_success() {
        println!("  Bet accepted. Checking solvency...");

        // Pool must remain solvent
        let check = model.check_invariant();
        assert!(
            check.is_ok(),
            "ğŸ”¥ EXPLOIT SUCCEEDED: Huge payout broke invariant: {:?}",
            check
        );

        // Pool reserve should not be drained below safety threshold
        assert!(
            model.pool_reserve > 0,
            "ğŸ”¥ EXPLOIT SUCCEEDED: Pool completely drained"
        );

        println!("  âœ“ Pool remained solvent after large payout");
    } else {
        println!("  âœ“ Bet rejected upfront: {}", attack_result.message());
    }

    println!("\nâœ… ATTACK THWARTED: Max payout limit enforced");
}

#[test]
fn attack_dust_share_theft() {
    println!("\nğŸ”´ ATTACK: Dust attack on LP shares");
    println!("Strategy: Deposit tiny amount to get 0 shares but tokens stay in pool");

    let mut model = AccountingModel::new();

    // Setup: Create large pool
    println!("Setup: Creating large pool...");
    let lp1 = 1;
    model.lp_deposit(lp1, 1_000_000_000).expect_success(); // 1000 USDT

    let initial_reserve = model.pool_reserve;
    let initial_shares = model.total_shares;
    println!("  Reserve: {} USDT", initial_reserve / 1_000_000);
    println!("  Shares: {}", initial_shares);

    // Attack: Deposit tiny amount
    println!("\nğŸš¨ ATTACK EXECUTION:");
    let attacker = 999;
    let dust_amount = 1; // 1 unit (0.000001 USDT)

    println!("  Attacker deposits {} units (dust)", dust_amount);

    let attack_result = model.lp_deposit(attacker, dust_amount);

    // Verify: Either rejected or attacker gets fair treatment
    println!("\nâœ… DEFENSE CHECK:");

    if attack_result.is_success() {
        let attacker_shares = model.lp_shares.get(&attacker).unwrap_or(&0);
        println!("  Attacker shares: {}", attacker_shares);

        if *attacker_shares == 0 {
            // Attacker got 0 shares - donated to pool
            println!("  âš ï¸  Attacker received 0 shares (donated {} to pool)", dust_amount);

            // This is not necessarily an exploit - attacker just donated
            // But verify pool state is consistent
            let new_reserve = model.pool_reserve;
            println!("  New reserve: {} (increased by {})", new_reserve, new_reserve - initial_reserve);
        } else {
            println!("  âœ“ Attacker received shares proportional to deposit");
        }

        // Check invariants
        let check = model.check_invariant();
        assert!(
            check.is_ok(),
            "ğŸ”¥ EXPLOIT SUCCEEDED: Dust deposit broke invariant: {:?}",
            check
        );
    } else {
        println!("  âœ“ Dust deposit rejected: {}", attack_result.message());
    }

    println!("\nâœ… ATTACK THWARTED: Dust deposits handled safely");
}

#[test]
fn attack_pool_drain_max_bets() {
    println!("\nğŸ”´ ATTACK: Pool drain via maximum bets");
    println!("Strategy: Drain entire pool through repeated max bets + luck");

    let mut model = AccountingModel::new();

    // Setup: Create pool at minimum operating balance
    println!("Setup: Creating pool at minimum operating balance...");
    let lp = 1;
    let min_operating = 100_000_000; // 100 USDT
    model.lp_deposit(lp, min_operating).expect_success();

    println!("  Pool reserve: {} USDT", model.pool_reserve / 1_000_000);

    // Attack: Repeatedly bet max at highest multiplier
    println!("\nğŸš¨ ATTACK EXECUTION:");
    let attacker = 999;
    model.user_deposit(attacker, 50_000_000).expect_success(); // 50 USDT

    let mut attempts = 0;
    let max_attempts = 100;
    let mut total_drained = 0u64;

    while model.pool_reserve > 0 && attempts < max_attempts {
        let player_balance = *model.user_balances.get(&attacker).unwrap_or(&0);

        if player_balance < 1_000_000 {
            // Player needs more money
            model.user_deposit(attacker, 20_000_000).expect_success();
        }

        // Bet big, win big
        let bet: u64 = std::cmp::min(5_000_000, player_balance); // 5 USDT or max balance
        let multiplier: u64 = 10; // 10x
        let payout: u64 = bet * multiplier;
        let profit: u64 = payout.saturating_sub(bet);

        // Check if this would drain pool below safety
        if profit > model.pool_reserve {
            println!("  Attempt {}: Bet would drain pool (profit {} > reserve {})",
                     attempts + 1, profit / 1_000_000, model.pool_reserve / 1_000_000);

            // Try the bet anyway to see if it's rejected
            let result = model.settle_bet(attacker, bet, payout);

            if result.is_success() {
                println!("    âš ï¸  Bet accepted despite insufficient reserve!");
                total_drained += profit;
            } else {
                println!("    âœ“ Bet rejected: {}", result.message());
                break;
            }
        } else {
            // Safe bet
            let result = model.settle_bet(attacker, bet, payout);
            if result.is_success() {
                total_drained += profit;
            } else {
                break;
            }
        }

        attempts += 1;
    }

    println!("  Total attempts: {}", attempts);
    println!("  Total drained: {} USDT", total_drained / 1_000_000);
    println!("  Final reserve: {} USDT", model.pool_reserve / 1_000_000);

    // Verify: Pool should never go below safety threshold or negative
    println!("\nâœ… DEFENSE CHECK:");

    // Pool should either:
    // 1. Still have reserve, OR
    // 2. Have stopped accepting bets before draining completely

    // The critical check is invariant must hold
    let check = model.check_invariant();
    assert!(
        check.is_ok(),
        "ğŸ”¥ EXPLOIT SUCCEEDED: Pool drain broke invariant: {:?}",
        check
    );

    println!("  âœ“ Pool maintained solvency throughout drain attempts");
    println!("\nâœ… ATTACK THWARTED: Pool drain prevented or handled safely");
}

#[test]
fn attack_min_operating_balance_bypass() {
    println!("\nğŸ”´ ATTACK: Minimum operating balance bypass");
    println!("Strategy: Force pool below MIN_OPERATING_BALANCE and try to operate");

    let mut model = AccountingModel::new();

    // Setup: Create pool at exactly minimum operating balance
    println!("Setup: Creating pool at minimum...");
    let lp = 1;
    let min_operating = 100_000_000; // 100 USDT (MIN_OPERATING_BALANCE)
    model.lp_deposit(lp, min_operating).expect_success();

    println!("  Pool reserve: {} USDT", model.pool_reserve / 1_000_000);

    // Try to drain it below minimum
    println!("\nğŸš¨ ATTACK EXECUTION (Phase 1): Draining to below minimum...");
    let attacker = 999;
    model.user_deposit(attacker, 50_000_000).expect_success();

    // Win big to drain pool
    let mut drain_attempts = 0;
    while model.pool_reserve > min_operating / 2 && drain_attempts < 20 {
        let bet = 1_000_000; // 1 USDT
        let payout = bet * 5; // 5x
        let profit = payout - bet;

        if profit <= model.pool_reserve {
            let result = model.settle_bet(attacker, bet, payout);
            if !result.is_success() {
                println!("  Bet rejected: {}", result.message());
                break;
            }
            drain_attempts += 1;
        } else {
            break;
        }
    }

    println!("  Reserve after draining: {} USDT", model.pool_reserve / 1_000_000);

    // Attack: Try to play games when pool is below minimum
    println!("\nğŸš¨ ATTACK EXECUTION (Phase 2): Operating below minimum...");

    let victim = 888;
    model.user_deposit(victim, 10_000_000).expect_success();

    let bet = 1_000_000; // 1 USDT
    let payout = bet * 2; // 2x win

    println!("  Victim attempts bet when reserve = {} USDT", model.pool_reserve / 1_000_000);
    let game_result = model.settle_bet(victim, bet, payout);

    // Verify: Game should be rejected or pool should remain solvent
    println!("\nâœ… DEFENSE CHECK:");

    if game_result.is_success() {
        println!("  Game accepted below minimum operating balance");

        // Check invariants
        let check = model.check_invariant();
        assert!(
            check.is_ok(),
            "ğŸ”¥ EXPLOIT SUCCEEDED: Operating below minimum broke invariant: {:?}",
            check
        );

        println!("  âœ“ Pool remained solvent despite low balance");
    } else {
        println!("  âœ“ Game rejected: {}", game_result.message());
    }

    println!("\nâœ… ATTACK THWARTED: Minimum operating balance enforced");
}

#[test]
fn attack_zero_value_operations() {
    println!("\nğŸ”´ ATTACK: Zero value operations");
    println!("Strategy: Try various operations with zero amounts");

    let mut model = AccountingModel::new();

    // Setup
    println!("Setup: Creating pool...");
    let lp = 1;
    model.lp_deposit(lp, 100_000_000).expect_success();

    // Attack: Try zero-value operations
    println!("\nğŸš¨ ATTACK EXECUTION:");

    let attacker = 999;

    println!("  Attempt 1: Zero user deposit");
    let r1 = model.user_deposit(attacker, 0);
    println!("    Result: {}", r1.message());

    println!("  Attempt 2: Zero LP deposit");
    let r2 = model.lp_deposit(attacker, 0);
    println!("    Result: {}", r2.message());

    println!("  Attempt 3: Zero bet (total loss)");
    model.user_deposit(attacker, 1_000_000).expect_success(); // Give some balance
    let r3 = model.settle_bet(attacker, 0, 0);
    println!("    Result: {}", r3.message());

    // Verify: All should be rejected or handled safely
    println!("\nâœ… DEFENSE CHECK:");

    let check = model.check_invariant();
    assert!(
        check.is_ok(),
        "ğŸ”¥ EXPLOIT SUCCEEDED: Zero value operations broke invariant: {:?}",
        check
    );

    println!("  âœ“ Zero value operations handled safely");
    println!("\nâœ… ATTACK THWARTED: Zero value operations prevented");
}

#[test]
fn attack_max_value_operations() {
    println!("\nğŸ”´ ATTACK: Maximum value operations");
    println!("Strategy: Try operations with u64::MAX values");

    let mut model = AccountingModel::new();

    // Attack: Try max value operations
    println!("\nğŸš¨ ATTACK EXECUTION:");

    let attacker = 999;

    println!("  Attempt 1: MAX user deposit");
    let r1 = model.user_deposit(attacker, u64::MAX);
    println!("    Result: {}", r1.message());

    println!("  Attempt 2: MAX LP deposit");
    let r2 = model.lp_deposit(attacker, u64::MAX);
    println!("    Result: {}", r2.message());

    // If any succeeded, verify invariants
    println!("\nâœ… DEFENSE CHECK:");

    if r1.is_success() || r2.is_success() {
        let check = model.check_invariant();
        assert!(
            check.is_ok(),
            "ğŸ”¥ EXPLOIT SUCCEEDED: MAX value operations broke invariant: {:?}",
            check
        );

        println!("  âœ“ MAX value operations handled without overflow");
    } else {
        println!("  âœ“ MAX value operations rejected");
    }

    println!("\nâœ… ATTACK THWARTED: Maximum value operations handled safely");
}

// Helper trait
trait IsSuccess {
    fn is_success(&self) -> bool;
    fn message(&self) -> String;
}

use crate::defi_accounting::tests::stress_tests::OpResult;

impl IsSuccess for OpResult {
    fn is_success(&self) -> bool {
        matches!(self, OpResult::Success)
    }

    fn message(&self) -> String {
        format!("{:?}", self)
    }
}

trait ExpectSuccess {
    fn expect_success(self) -> Self;
}

impl ExpectSuccess for crate::defi_accounting::tests::stress_tests::OpResult {
    fn expect_success(self) -> Self {
        assert!(self.is_success(), "Operation failed: {}", self.message());
        self
    }
}
